// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum PodDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PodData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PodData<'a> {
  type Inner = PodData<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> PodData<'a> {
  pub const VT_BATTERY_PACK_CURRENT: flatbuffers::VOffsetT = 4;
  pub const VT_AVERAGE_CELL_TEMPERATURE: flatbuffers::VOffsetT = 6;
  pub const VT_IGBT_TEMP: flatbuffers::VOffsetT = 8;
  pub const VT_MOTOR_VOLTAGE: flatbuffers::VOffsetT = 10;
  pub const VT_BATTERY_PACK_VOLTAGE: flatbuffers::VOffsetT = 12;
  pub const VT_STATE_OF_CHARGE: flatbuffers::VOffsetT = 14;
  pub const VT_BUCK_TEMPERATURE: flatbuffers::VOffsetT = 16;
  pub const VT_BMS_CURRENT: flatbuffers::VOffsetT = 18;
  pub const VT_LINK_CAP_VOLTAGE: flatbuffers::VOffsetT = 20;
  pub const VT_MC_POD_SPEED: flatbuffers::VOffsetT = 22;
  pub const VT_MOTOR_CURRENT: flatbuffers::VOffsetT = 24;
  pub const VT_BATTERY_CURRENT: flatbuffers::VOffsetT = 26;
  pub const VT_BATTERY_VOLTAGE: flatbuffers::VOffsetT = 28;
  pub const VT_SPEED: flatbuffers::VOffsetT = 30;
  pub const VT_CURRENT_5V: flatbuffers::VOffsetT = 32;
  pub const VT_CURRENT_12V: flatbuffers::VOffsetT = 34;
  pub const VT_CURRENT_24V: flatbuffers::VOffsetT = 36;
  pub const VT_TORCHIC_1: flatbuffers::VOffsetT = 38;
  pub const VT_TORCHIC_2: flatbuffers::VOffsetT = 40;
  pub const VT_PRESSURE_HIGH: flatbuffers::VOffsetT = 42;
  pub const VT_PRESSURE_LOW_1: flatbuffers::VOffsetT = 44;
  pub const VT_PRESSURE_LOW_2: flatbuffers::VOffsetT = 46;
  pub const VT_ROBOTEQ_MOTOR_1_SPEED: flatbuffers::VOffsetT = 48;
  pub const VT_ROBOTEQ_MOTOR_2_SPEED: flatbuffers::VOffsetT = 50;
  pub const VT_ROBOTEQ_MOTOR_1_BATTERY_AMPS: flatbuffers::VOffsetT = 52;
  pub const VT_ROBOTEQ_MOTOR_2_BATTERY_AMPS: flatbuffers::VOffsetT = 54;
  pub const VT_ROBOTEQ_MCU_TEMP: flatbuffers::VOffsetT = 56;
  pub const VT_ROBOTEQ_SENSOR_1_TEMP: flatbuffers::VOffsetT = 58;
  pub const VT_ROBOTEQ_SENSOR_2_TEMP: flatbuffers::VOffsetT = 60;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PodData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PodDataArgs<'args>
  ) -> flatbuffers::WIPOffset<PodData<'bldr>> {
    let mut builder = PodDataBuilder::new(_fbb);
    if let Some(x) = args.roboteq_motor_2_speed { builder.add_roboteq_motor_2_speed(x); }
    if let Some(x) = args.roboteq_motor_1_speed { builder.add_roboteq_motor_1_speed(x); }
    if let Some(x) = args.pressure_low_2 { builder.add_pressure_low_2(x); }
    if let Some(x) = args.pressure_low_1 { builder.add_pressure_low_1(x); }
    if let Some(x) = args.pressure_high { builder.add_pressure_high(x); }
    if let Some(x) = args.torchic_2 { builder.add_torchic_2(x); }
    if let Some(x) = args.torchic_1 { builder.add_torchic_1(x); }
    if let Some(x) = args.current_24v { builder.add_current_24v(x); }
    if let Some(x) = args.current_12v { builder.add_current_12v(x); }
    if let Some(x) = args.current_5v { builder.add_current_5v(x); }
    if let Some(x) = args.speed { builder.add_speed(x); }
    if let Some(x) = args.battery_voltage { builder.add_battery_voltage(x); }
    if let Some(x) = args.battery_current { builder.add_battery_current(x); }
    if let Some(x) = args.motor_current { builder.add_motor_current(x); }
    if let Some(x) = args.mc_pod_speed { builder.add_mc_pod_speed(x); }
    if let Some(x) = args.link_cap_voltage { builder.add_link_cap_voltage(x); }
    if let Some(x) = args.bms_current { builder.add_bms_current(x); }
    if let Some(x) = args.buck_temperature { builder.add_buck_temperature(x); }
    if let Some(x) = args.state_of_charge { builder.add_state_of_charge(x); }
    if let Some(x) = args.battery_pack_voltage { builder.add_battery_pack_voltage(x); }
    if let Some(x) = args.motor_voltage { builder.add_motor_voltage(x); }
    if let Some(x) = args.igbt_temp { builder.add_igbt_temp(x); }
    if let Some(x) = args.average_cell_temperature { builder.add_average_cell_temperature(x); }
    if let Some(x) = args.battery_pack_current { builder.add_battery_pack_current(x); }
    if let Some(x) = args.roboteq_motor_2_battery_amps { builder.add_roboteq_motor_2_battery_amps(x); }
    if let Some(x) = args.roboteq_motor_1_battery_amps { builder.add_roboteq_motor_1_battery_amps(x); }
    if let Some(x) = args.roboteq_sensor_2_temp { builder.add_roboteq_sensor_2_temp(x); }
    if let Some(x) = args.roboteq_sensor_1_temp { builder.add_roboteq_sensor_1_temp(x); }
    if let Some(x) = args.roboteq_mcu_temp { builder.add_roboteq_mcu_temp(x); }
    builder.finish()
  }


  #[inline]
  pub fn battery_pack_current(&self) -> Option<f32> {
    self._tab.get::<f32>(PodData::VT_BATTERY_PACK_CURRENT, None)
  }
  #[inline]
  pub fn average_cell_temperature(&self) -> Option<f32> {
    self._tab.get::<f32>(PodData::VT_AVERAGE_CELL_TEMPERATURE, None)
  }
  #[inline]
  pub fn igbt_temp(&self) -> Option<f32> {
    self._tab.get::<f32>(PodData::VT_IGBT_TEMP, None)
  }
  #[inline]
  pub fn motor_voltage(&self) -> Option<f32> {
    self._tab.get::<f32>(PodData::VT_MOTOR_VOLTAGE, None)
  }
  #[inline]
  pub fn battery_pack_voltage(&self) -> Option<f32> {
    self._tab.get::<f32>(PodData::VT_BATTERY_PACK_VOLTAGE, None)
  }
  #[inline]
  pub fn state_of_charge(&self) -> Option<f32> {
    self._tab.get::<f32>(PodData::VT_STATE_OF_CHARGE, None)
  }
  #[inline]
  pub fn buck_temperature(&self) -> Option<f32> {
    self._tab.get::<f32>(PodData::VT_BUCK_TEMPERATURE, None)
  }
  #[inline]
  pub fn bms_current(&self) -> Option<f32> {
    self._tab.get::<f32>(PodData::VT_BMS_CURRENT, None)
  }
  #[inline]
  pub fn link_cap_voltage(&self) -> Option<f32> {
    self._tab.get::<f32>(PodData::VT_LINK_CAP_VOLTAGE, None)
  }
  #[inline]
  pub fn mc_pod_speed(&self) -> Option<f32> {
    self._tab.get::<f32>(PodData::VT_MC_POD_SPEED, None)
  }
  #[inline]
  pub fn motor_current(&self) -> Option<f32> {
    self._tab.get::<f32>(PodData::VT_MOTOR_CURRENT, None)
  }
  #[inline]
  pub fn battery_current(&self) -> Option<f32> {
    self._tab.get::<f32>(PodData::VT_BATTERY_CURRENT, None)
  }
  #[inline]
  pub fn battery_voltage(&self) -> Option<f32> {
    self._tab.get::<f32>(PodData::VT_BATTERY_VOLTAGE, None)
  }
  #[inline]
  pub fn speed(&self) -> Option<f32> {
    self._tab.get::<f32>(PodData::VT_SPEED, None)
  }
  #[inline]
  pub fn current_5v(&self) -> Option<f32> {
    self._tab.get::<f32>(PodData::VT_CURRENT_5V, None)
  }
  #[inline]
  pub fn current_12v(&self) -> Option<f32> {
    self._tab.get::<f32>(PodData::VT_CURRENT_12V, None)
  }
  #[inline]
  pub fn current_24v(&self) -> Option<f32> {
    self._tab.get::<f32>(PodData::VT_CURRENT_24V, None)
  }
  #[inline]
  pub fn torchic_1(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(PodData::VT_TORCHIC_1, None)
  }
  #[inline]
  pub fn torchic_2(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(PodData::VT_TORCHIC_2, None)
  }
  #[inline]
  pub fn pressure_high(&self) -> Option<f32> {
    self._tab.get::<f32>(PodData::VT_PRESSURE_HIGH, None)
  }
  #[inline]
  pub fn pressure_low_1(&self) -> Option<f32> {
    self._tab.get::<f32>(PodData::VT_PRESSURE_LOW_1, None)
  }
  #[inline]
  pub fn pressure_low_2(&self) -> Option<f32> {
    self._tab.get::<f32>(PodData::VT_PRESSURE_LOW_2, None)
  }
  #[inline]
  pub fn roboteq_motor_1_speed(&self) -> Option<f64> {
    self._tab.get::<f64>(PodData::VT_ROBOTEQ_MOTOR_1_SPEED, None)
  }
  #[inline]
  pub fn roboteq_motor_2_speed(&self) -> Option<f64> {
    self._tab.get::<f64>(PodData::VT_ROBOTEQ_MOTOR_2_SPEED, None)
  }
  #[inline]
  pub fn roboteq_motor_1_battery_amps(&self) -> Option<i16> {
    self._tab.get::<i16>(PodData::VT_ROBOTEQ_MOTOR_1_BATTERY_AMPS, None)
  }
  #[inline]
  pub fn roboteq_motor_2_battery_amps(&self) -> Option<i16> {
    self._tab.get::<i16>(PodData::VT_ROBOTEQ_MOTOR_2_BATTERY_AMPS, None)
  }
  #[inline]
  pub fn roboteq_mcu_temp(&self) -> Option<i8> {
    self._tab.get::<i8>(PodData::VT_ROBOTEQ_MCU_TEMP, None)
  }
  #[inline]
  pub fn roboteq_sensor_1_temp(&self) -> Option<i8> {
    self._tab.get::<i8>(PodData::VT_ROBOTEQ_SENSOR_1_TEMP, None)
  }
  #[inline]
  pub fn roboteq_sensor_2_temp(&self) -> Option<i8> {
    self._tab.get::<i8>(PodData::VT_ROBOTEQ_SENSOR_2_TEMP, None)
  }
}

impl flatbuffers::Verifiable for PodData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("battery_pack_current", Self::VT_BATTERY_PACK_CURRENT, false)?
     .visit_field::<f32>("average_cell_temperature", Self::VT_AVERAGE_CELL_TEMPERATURE, false)?
     .visit_field::<f32>("igbt_temp", Self::VT_IGBT_TEMP, false)?
     .visit_field::<f32>("motor_voltage", Self::VT_MOTOR_VOLTAGE, false)?
     .visit_field::<f32>("battery_pack_voltage", Self::VT_BATTERY_PACK_VOLTAGE, false)?
     .visit_field::<f32>("state_of_charge", Self::VT_STATE_OF_CHARGE, false)?
     .visit_field::<f32>("buck_temperature", Self::VT_BUCK_TEMPERATURE, false)?
     .visit_field::<f32>("bms_current", Self::VT_BMS_CURRENT, false)?
     .visit_field::<f32>("link_cap_voltage", Self::VT_LINK_CAP_VOLTAGE, false)?
     .visit_field::<f32>("mc_pod_speed", Self::VT_MC_POD_SPEED, false)?
     .visit_field::<f32>("motor_current", Self::VT_MOTOR_CURRENT, false)?
     .visit_field::<f32>("battery_current", Self::VT_BATTERY_CURRENT, false)?
     .visit_field::<f32>("battery_voltage", Self::VT_BATTERY_VOLTAGE, false)?
     .visit_field::<f32>("speed", Self::VT_SPEED, false)?
     .visit_field::<f32>("current_5v", Self::VT_CURRENT_5V, false)?
     .visit_field::<f32>("current_12v", Self::VT_CURRENT_12V, false)?
     .visit_field::<f32>("current_24v", Self::VT_CURRENT_24V, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("torchic_1", Self::VT_TORCHIC_1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("torchic_2", Self::VT_TORCHIC_2, false)?
     .visit_field::<f32>("pressure_high", Self::VT_PRESSURE_HIGH, false)?
     .visit_field::<f32>("pressure_low_1", Self::VT_PRESSURE_LOW_1, false)?
     .visit_field::<f32>("pressure_low_2", Self::VT_PRESSURE_LOW_2, false)?
     .visit_field::<f64>("roboteq_motor_1_speed", Self::VT_ROBOTEQ_MOTOR_1_SPEED, false)?
     .visit_field::<f64>("roboteq_motor_2_speed", Self::VT_ROBOTEQ_MOTOR_2_SPEED, false)?
     .visit_field::<i16>("roboteq_motor_1_battery_amps", Self::VT_ROBOTEQ_MOTOR_1_BATTERY_AMPS, false)?
     .visit_field::<i16>("roboteq_motor_2_battery_amps", Self::VT_ROBOTEQ_MOTOR_2_BATTERY_AMPS, false)?
     .visit_field::<i8>("roboteq_mcu_temp", Self::VT_ROBOTEQ_MCU_TEMP, false)?
     .visit_field::<i8>("roboteq_sensor_1_temp", Self::VT_ROBOTEQ_SENSOR_1_TEMP, false)?
     .visit_field::<i8>("roboteq_sensor_2_temp", Self::VT_ROBOTEQ_SENSOR_2_TEMP, false)?
     .finish();
    Ok(())
  }
}
pub struct PodDataArgs<'a> {
    pub battery_pack_current: Option<f32>,
    pub average_cell_temperature: Option<f32>,
    pub igbt_temp: Option<f32>,
    pub motor_voltage: Option<f32>,
    pub battery_pack_voltage: Option<f32>,
    pub state_of_charge: Option<f32>,
    pub buck_temperature: Option<f32>,
    pub bms_current: Option<f32>,
    pub link_cap_voltage: Option<f32>,
    pub mc_pod_speed: Option<f32>,
    pub motor_current: Option<f32>,
    pub battery_current: Option<f32>,
    pub battery_voltage: Option<f32>,
    pub speed: Option<f32>,
    pub current_5v: Option<f32>,
    pub current_12v: Option<f32>,
    pub current_24v: Option<f32>,
    pub torchic_1: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub torchic_2: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub pressure_high: Option<f32>,
    pub pressure_low_1: Option<f32>,
    pub pressure_low_2: Option<f32>,
    pub roboteq_motor_1_speed: Option<f64>,
    pub roboteq_motor_2_speed: Option<f64>,
    pub roboteq_motor_1_battery_amps: Option<i16>,
    pub roboteq_motor_2_battery_amps: Option<i16>,
    pub roboteq_mcu_temp: Option<i8>,
    pub roboteq_sensor_1_temp: Option<i8>,
    pub roboteq_sensor_2_temp: Option<i8>,
}
impl<'a> Default for PodDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    PodDataArgs {
      battery_pack_current: None,
      average_cell_temperature: None,
      igbt_temp: None,
      motor_voltage: None,
      battery_pack_voltage: None,
      state_of_charge: None,
      buck_temperature: None,
      bms_current: None,
      link_cap_voltage: None,
      mc_pod_speed: None,
      motor_current: None,
      battery_current: None,
      battery_voltage: None,
      speed: None,
      current_5v: None,
      current_12v: None,
      current_24v: None,
      torchic_1: None,
      torchic_2: None,
      pressure_high: None,
      pressure_low_1: None,
      pressure_low_2: None,
      roboteq_motor_1_speed: None,
      roboteq_motor_2_speed: None,
      roboteq_motor_1_battery_amps: None,
      roboteq_motor_2_battery_amps: None,
      roboteq_mcu_temp: None,
      roboteq_sensor_1_temp: None,
      roboteq_sensor_2_temp: None,
    }
  }
}

pub struct PodDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PodDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_battery_pack_current(&mut self, battery_pack_current: f32) {
    self.fbb_.push_slot_always::<f32>(PodData::VT_BATTERY_PACK_CURRENT, battery_pack_current);
  }
  #[inline]
  pub fn add_average_cell_temperature(&mut self, average_cell_temperature: f32) {
    self.fbb_.push_slot_always::<f32>(PodData::VT_AVERAGE_CELL_TEMPERATURE, average_cell_temperature);
  }
  #[inline]
  pub fn add_igbt_temp(&mut self, igbt_temp: f32) {
    self.fbb_.push_slot_always::<f32>(PodData::VT_IGBT_TEMP, igbt_temp);
  }
  #[inline]
  pub fn add_motor_voltage(&mut self, motor_voltage: f32) {
    self.fbb_.push_slot_always::<f32>(PodData::VT_MOTOR_VOLTAGE, motor_voltage);
  }
  #[inline]
  pub fn add_battery_pack_voltage(&mut self, battery_pack_voltage: f32) {
    self.fbb_.push_slot_always::<f32>(PodData::VT_BATTERY_PACK_VOLTAGE, battery_pack_voltage);
  }
  #[inline]
  pub fn add_state_of_charge(&mut self, state_of_charge: f32) {
    self.fbb_.push_slot_always::<f32>(PodData::VT_STATE_OF_CHARGE, state_of_charge);
  }
  #[inline]
  pub fn add_buck_temperature(&mut self, buck_temperature: f32) {
    self.fbb_.push_slot_always::<f32>(PodData::VT_BUCK_TEMPERATURE, buck_temperature);
  }
  #[inline]
  pub fn add_bms_current(&mut self, bms_current: f32) {
    self.fbb_.push_slot_always::<f32>(PodData::VT_BMS_CURRENT, bms_current);
  }
  #[inline]
  pub fn add_link_cap_voltage(&mut self, link_cap_voltage: f32) {
    self.fbb_.push_slot_always::<f32>(PodData::VT_LINK_CAP_VOLTAGE, link_cap_voltage);
  }
  #[inline]
  pub fn add_mc_pod_speed(&mut self, mc_pod_speed: f32) {
    self.fbb_.push_slot_always::<f32>(PodData::VT_MC_POD_SPEED, mc_pod_speed);
  }
  #[inline]
  pub fn add_motor_current(&mut self, motor_current: f32) {
    self.fbb_.push_slot_always::<f32>(PodData::VT_MOTOR_CURRENT, motor_current);
  }
  #[inline]
  pub fn add_battery_current(&mut self, battery_current: f32) {
    self.fbb_.push_slot_always::<f32>(PodData::VT_BATTERY_CURRENT, battery_current);
  }
  #[inline]
  pub fn add_battery_voltage(&mut self, battery_voltage: f32) {
    self.fbb_.push_slot_always::<f32>(PodData::VT_BATTERY_VOLTAGE, battery_voltage);
  }
  #[inline]
  pub fn add_speed(&mut self, speed: f32) {
    self.fbb_.push_slot_always::<f32>(PodData::VT_SPEED, speed);
  }
  #[inline]
  pub fn add_current_5v(&mut self, current_5v: f32) {
    self.fbb_.push_slot_always::<f32>(PodData::VT_CURRENT_5V, current_5v);
  }
  #[inline]
  pub fn add_current_12v(&mut self, current_12v: f32) {
    self.fbb_.push_slot_always::<f32>(PodData::VT_CURRENT_12V, current_12v);
  }
  #[inline]
  pub fn add_current_24v(&mut self, current_24v: f32) {
    self.fbb_.push_slot_always::<f32>(PodData::VT_CURRENT_24V, current_24v);
  }
  #[inline]
  pub fn add_torchic_1(&mut self, torchic_1: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PodData::VT_TORCHIC_1, torchic_1);
  }
  #[inline]
  pub fn add_torchic_2(&mut self, torchic_2: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PodData::VT_TORCHIC_2, torchic_2);
  }
  #[inline]
  pub fn add_pressure_high(&mut self, pressure_high: f32) {
    self.fbb_.push_slot_always::<f32>(PodData::VT_PRESSURE_HIGH, pressure_high);
  }
  #[inline]
  pub fn add_pressure_low_1(&mut self, pressure_low_1: f32) {
    self.fbb_.push_slot_always::<f32>(PodData::VT_PRESSURE_LOW_1, pressure_low_1);
  }
  #[inline]
  pub fn add_pressure_low_2(&mut self, pressure_low_2: f32) {
    self.fbb_.push_slot_always::<f32>(PodData::VT_PRESSURE_LOW_2, pressure_low_2);
  }
  #[inline]
  pub fn add_roboteq_motor_1_speed(&mut self, roboteq_motor_1_speed: f64) {
    self.fbb_.push_slot_always::<f64>(PodData::VT_ROBOTEQ_MOTOR_1_SPEED, roboteq_motor_1_speed);
  }
  #[inline]
  pub fn add_roboteq_motor_2_speed(&mut self, roboteq_motor_2_speed: f64) {
    self.fbb_.push_slot_always::<f64>(PodData::VT_ROBOTEQ_MOTOR_2_SPEED, roboteq_motor_2_speed);
  }
  #[inline]
  pub fn add_roboteq_motor_1_battery_amps(&mut self, roboteq_motor_1_battery_amps: i16) {
    self.fbb_.push_slot_always::<i16>(PodData::VT_ROBOTEQ_MOTOR_1_BATTERY_AMPS, roboteq_motor_1_battery_amps);
  }
  #[inline]
  pub fn add_roboteq_motor_2_battery_amps(&mut self, roboteq_motor_2_battery_amps: i16) {
    self.fbb_.push_slot_always::<i16>(PodData::VT_ROBOTEQ_MOTOR_2_BATTERY_AMPS, roboteq_motor_2_battery_amps);
  }
  #[inline]
  pub fn add_roboteq_mcu_temp(&mut self, roboteq_mcu_temp: i8) {
    self.fbb_.push_slot_always::<i8>(PodData::VT_ROBOTEQ_MCU_TEMP, roboteq_mcu_temp);
  }
  #[inline]
  pub fn add_roboteq_sensor_1_temp(&mut self, roboteq_sensor_1_temp: i8) {
    self.fbb_.push_slot_always::<i8>(PodData::VT_ROBOTEQ_SENSOR_1_TEMP, roboteq_sensor_1_temp);
  }
  #[inline]
  pub fn add_roboteq_sensor_2_temp(&mut self, roboteq_sensor_2_temp: i8) {
    self.fbb_.push_slot_always::<i8>(PodData::VT_ROBOTEQ_SENSOR_2_TEMP, roboteq_sensor_2_temp);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PodDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PodDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PodData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PodData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PodData");
      ds.field("battery_pack_current", &self.battery_pack_current());
      ds.field("average_cell_temperature", &self.average_cell_temperature());
      ds.field("igbt_temp", &self.igbt_temp());
      ds.field("motor_voltage", &self.motor_voltage());
      ds.field("battery_pack_voltage", &self.battery_pack_voltage());
      ds.field("state_of_charge", &self.state_of_charge());
      ds.field("buck_temperature", &self.buck_temperature());
      ds.field("bms_current", &self.bms_current());
      ds.field("link_cap_voltage", &self.link_cap_voltage());
      ds.field("mc_pod_speed", &self.mc_pod_speed());
      ds.field("motor_current", &self.motor_current());
      ds.field("battery_current", &self.battery_current());
      ds.field("battery_voltage", &self.battery_voltage());
      ds.field("speed", &self.speed());
      ds.field("current_5v", &self.current_5v());
      ds.field("current_12v", &self.current_12v());
      ds.field("current_24v", &self.current_24v());
      ds.field("torchic_1", &self.torchic_1());
      ds.field("torchic_2", &self.torchic_2());
      ds.field("pressure_high", &self.pressure_high());
      ds.field("pressure_low_1", &self.pressure_low_1());
      ds.field("pressure_low_2", &self.pressure_low_2());
      ds.field("roboteq_motor_1_speed", &self.roboteq_motor_1_speed());
      ds.field("roboteq_motor_2_speed", &self.roboteq_motor_2_speed());
      ds.field("roboteq_motor_1_battery_amps", &self.roboteq_motor_1_battery_amps());
      ds.field("roboteq_motor_2_battery_amps", &self.roboteq_motor_2_battery_amps());
      ds.field("roboteq_mcu_temp", &self.roboteq_mcu_temp());
      ds.field("roboteq_sensor_1_temp", &self.roboteq_sensor_1_temp());
      ds.field("roboteq_sensor_2_temp", &self.roboteq_sensor_2_temp());
      ds.finish()
  }
}
